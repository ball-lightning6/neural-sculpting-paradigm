import json
import random
import math
from collections import deque

# ==============================================================================
# --- 1. 核心参数配置 ---
# ==============================================================================
# 图的节点数 N x N (注意：N>12，暴力解法会非常慢)
GRAPH_SIZE_N = 8
# 初始感染节点的数量
NUM_INITIAL = 2

DATASET_SIZE = 300000

TRAIN_FILE = f'malware_spread_n{GRAPH_SIZE_N}_i{NUM_INITIAL}_format_train.jsonl'
EVAL_FILE = f'malware_spread_n{GRAPH_SIZE_N}_i{NUM_INITIAL}_eval.jsonl'

# ==============================================================================
# --- 2. 编码定义 ---
# ==============================================================================
# 输入是 [邻接矩阵] + [initial激活flag]
INPUT_LEN = GRAPH_SIZE_N * GRAPH_SIZE_N + GRAPH_SIZE_N
# 输出是每个initial节点是否是“最优移除点”的多标签
OUTPUT_LEN = GRAPH_SIZE_N

print("=" * 70)
print(f"     减少恶意软件传播 - 数据集生成器")
print("=" * 70)
print(f"图大小: {GRAPH_SIZE_N}x{GRAPH_SIZE_N}, 初始感染数: {NUM_INITIAL}")
print(f"输入格式: {INPUT_LEN}个'0'/'1'")
print(f"输出格式: {OUTPUT_LEN}个多标签二分类 (每个节点是否为最优解)")
print("=" * 70)

all_set = set()
# ==============================================================================
# --- 3. 核心逻辑：求解器 (暴力模拟所有可能性) ---
# ==============================================================================
def generate_problem(n, num_initial):
    """随机生成一个图和初始感染节点"""
    while True:
        # 生成一个随机的对称邻接矩阵
        graph = [[0] * n for _ in range(n)]
        for i in range(n):
            graph[i][i] = 1
            for j in range(i + 1, n):
                if random.random() < 0.3:  # 控制图的稀疏度
                    graph[i][j] = 1
                    graph[j][i] = 1
        graph_str = ''.join(''.join(str(x)) for x in graph)
        # 随机选择不重复的初始感染节点
        initial = random.sample(range(n), num_initial)
        initial_tuple = tuple(sorted(initial))
        if (graph_str,initial_tuple) not in all_set:
            all_set.add((graph_str,initial_tuple))
            return graph, initial


def bfs_spread(graph, start_nodes):
    """使用BFS计算从一组起始节点开始的感染范围"""
    n = len(graph)
    infected = set(start_nodes)
    queue = deque(list(start_nodes))

    while queue:
        u = queue.popleft()
        for v in range(n):
            if graph[u][v]==1 and v not in infected:
                infected.add(v)
                queue.append(v)

    return len(infected)


def solve_min_malware_spread(graph, initial):
    """
    通过暴力尝试移除每一个初始节点，找到最优解。
    """
    min_spread = float('inf')
    best_nodes_to_remove = []

    # 遍历每一个可以被移除的初始节点
    for node_to_remove in initial:
        # 构造移除该节点后的新初始感染集
        remaining_initial = [node for node in initial if node!=node_to_remove]

        if not remaining_initial:  # 如果移除后没有感染源了
            spread_size = 0
        else:
            spread_size = bfs_spread(graph, remaining_initial)

        if spread_size < min_spread:
            min_spread = spread_size
            best_nodes_to_remove = [node_to_remove]
        elif spread_size==min_spread:
            best_nodes_to_remove.append(node_to_remove)

    return best_nodes_to_remove


def process_sample(n, num_initial):
    """生成一个完整的 (输入, 输出) 数据对。"""
    while True:
        graph, initial = generate_problem(n, num_initial)

        # 1. 编码输入
        graph_str = "".join(str(cell) for row in graph for cell in row)
        initial_flags = [1 if i in initial else 0 for i in range(n)]
        initial_str = "".join(map(str, initial_flags))
        input_str = graph_str + initial_str

        # 2. 计算最优解
        nodes_to_remove = solve_min_malware_spread(graph, initial)
        if len(nodes_to_remove)==1:#!=NUM_INITIAL:
            break



    # 3. 编码输出
    # 输出是一个N-bit的向量，表示每个节点是否是一个最优解
    # 注意：我们只在initial集合的对应位置上标记
    #output_multilabel = [0] * n
    output_multilabel = []
    for node_idx in range(n):#nodes_to_remove:
        if initial_flags[node_idx]==1:
            if node_idx in nodes_to_remove:
                output_multilabel.append(1)
                break
            else:
                output_multilabel.append(0)
                break
        # output_multilabel[node_idx] = 1

    return {"input": input_str, "output": output_multilabel}


# ==============================================================================
# --- 4. 主生成函数 ---
# ==============================================================================
def generate_datasets(num_samples, n, num_initial):
    print("\n--- 开始生成数据集 ---")

    records = []
    for i in range(num_samples):
        records.append(process_sample(n, num_initial))
        if (i + 1) % 1000==0:
            print(f"已生成 {i + 1} / {num_samples} 条数据...")

    print(f"生成完毕。共 {len(records)} 条数据。")

    # --- 写入文件 ---
    # ... (省略)
    random.shuffle(records)
    train_size = int(len(records) * 1)#0.9)
    train_data, eval_data = records[:train_size], records[train_size:]

    def write_to_file(data, path, name):
        print(f"\n正在写入 {len(data)} 条{name}训练数据到 '{path[0]}'...")
        with open(path[0], 'w') as f:
            for record in data: f.write(json.dumps(record) + '\n')
        print(f"正在写入 {len(eval_data)} 条{name}评估数据到 '{path[1]}'...")
        with open(path[1], 'w') as f:
            for record in eval_data: f.write(json.dumps(record) + '\n')

    write_to_file(records, (TRAIN_FILE, EVAL_FILE), "")
    print("\n所有数据集生成完成！")


# ==============================================================================
# --- 5. 执行生成 ---
# ==============================================================================
if __name__=="__main__":
    generate_datasets(DATASET_SIZE, GRAPH_SIZE_N, NUM_INITIAL)